---
title: 工厂模式之简单工厂与工厂方法
date: 2020-11-15 16:48:24
tags:
---

# 工厂模式之简单工厂与工厂方法

1. 简单工厂模式

​		简单工厂模式其实并不算是一种设计模式，更多的时候更像是一种编程习惯

​		当我们定义一个工厂类，我们可以通过逻辑判断，根据传递的参数，来返回不同的实例，被创建的实例都具有共同的父类。

```python
class Moblie:
    def __init__(self):
        self.name = '手机'
class Computer:
    def __init__(self):
        self.name = '电脑'
# 工厂类
class factory():

    def example(self,name):
        if name=='moblie':
            result = Moblie()
            print(result.name)
        elif name == 'computer':
            result = Computer()
            print(result.name)

f = factory()
f.example('moblie')
```

​		这种设计思路使客户端免除直接创建产品对象的责任，也可以在不修改任何客户端代码的情况下更换和新增具体产品类，在一定程度上提高了系统灵活性。

​		不过缺点也有，有与工厂类集中了所有产品创建逻辑，一旦出现问题，整个系统都会受影响。当产品类型较多时，就会造成工厂逻辑过于复杂，不利于系统的扩展和维护。

​		所以一般在以下条件下使用工厂模式：1. 工厂类负责创建的对象比较少。2. 客户端不关心如何创建对象，不关心创建细节，只知道传入工厂类的参数。

2. 工厂方法模式

   ​	工程方法模式，也叫虚拟构造器模式或多态工厂模式，它属于创建型模式。

   ​	在工厂方法中，工厂父类负责定义创建产品对象的公共接口，子类负责生成具体的产品对象。

   ​	比如手机可以移动联网，电脑可以网线联网，客户端就可以将所有产品视为抽象的联网，客户端知道所有的联网对象都由上网的方法，但并不关心具体实现方式。

```python
class factory():
    @staticmethod
    def connect(self):
        pass

class mobile(factory):
    def __init__(self):
        self.name = '手机'

    def connect(self):
        print(self.name+"可以联网")

class computer(factory):
    def __init__(self):
        self.name = '电脑'

    def connect(self):
        print(self.name+"可以联网")

# 无论你加了多少个工厂，只需要实例化对应的那个具体工厂
f = computer()
f.connect()

```

​		工厂方法模式是简单工厂模式的进一步抽象和推广，使用了面向对象的多态性，即所有的具体工厂类都具有同一抽象父类。而且用户只需关心所需产品对应的工厂，无需关心创建细节。，再添加新的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，系统的可扩展性也就变得更好了。

​		工厂方法模式的缺点：当添加新的工厂类时，系统中类的个数将成对增加，也增加了系统的复杂度，有更多的类需要编译和运行，额外的增加了开销。由于引入了抽象层，增加了系统的抽象性和理解难度，而且可能会引入其他复杂的技术，如DOM,反射等技术，也增加了系统的实现难度。

​		工厂方法模式的使用场景：1. 客户端不需要知道它所创建的对象的类，只知道创建它的工厂名就可以。2. 客户端可以通过子类来指定创建对应的对象。