---
title: MySQL索引
date: 2020-11-17 20:36:49
tags:
---

# MYSQL索引

索引是MySQL的灵魂，是查询数据的根本。

1. 首先我们来了解一下MySQL数据库中，一条查询语句是如何执行的，索引在哪个环节，起到了什么作用。

   ​		当执行一条SQL语句时，首先会连接数据库服务器，然后服务器对SQL进行处理，数据库服务器会优先查看是否有该语句的缓存，key是SQL语句，value是查询的结果。如果缓存中有这条数据，就会直接将缓存中的结果返回给客户端。

   到这里结束的话，这条SQL语句就不会被解析，不会生成执行计划，也不会被执行。

   如果没有结束，缓存中没有结果的话，则开始第三步。

   1. 解析SQL：生成解析树，验证关键字如select,where,left join 等）是否正确。
   2. 预处理：进一步检查解析树是否合法，如 检查数据表和列是否存在，验证用户权限等。
   3. 优化SQL：决定使用哪个索引，或者在多个表相关联的时候决定表的连接顺序。紧接着，将SQL语句转成执行计划。

   最后会将查询的结果返回给客户端

2. 索引的基本概念

   索引是帮助数据库高效获取数据的数据结构。索引有以下分类：

   1. 从储存结构来划分有：Btree索引，哈希索引，full-index全文索引，Rtree
   2. 从应用参差上来划分：普通索引，唯一索引，复合索引。
   3. 从表记录的排列顺序和索引的排列顺序是否一致来划分：聚集索引和非聚集索引

3. Btree索引

   以前认为B+树是通过索引来实现的，现在发现好像说反了，索引反而是通过B+树来实现的。

   Btree索引的特点：

   1. 关键字分布在整棵树的所有节点。
   2. 任何一个关键字出现且只出现在一个节点中。
   3. 搜索有可能在非叶子节点结束。
   4. 其搜索性能等价于在关键字全集内做一次二分查找。

   ![Btree](MYSQL索引/Btree.png)

    	  当我们想要获得一条数据时，通过索引可以避免查询所有的数据，极大地减少了数据库查询的负担。

4. B+tree

   B+tree的基本特点：

   1. 非叶子节点的子树指针与关键字个数相同。
   2. 非叶子节点的子树指针`P[i]`，指向关键字属于 `[k[i],K[i+1]` 的子树`(区间是前闭后开)`。
   3. 为所有叶子节点增加一个链指针。
   4. 所有关键字都在叶子节点的链表中，且链表中的关键字是有序的。
   5. 搜索只在叶子节点命中。
   6. 非叶子节点相当于是叶子节点的索引层，叶子节点是存储关键字数据的数据层。

   ![B+tree](MySQL索引/B+tree.png)

5. Btree和B+tree的比较

   ​		B+树的磁盘读写代价更低。B+树的内部没有指向关键字具体信息的指针，所以其内部节点相对B树更小，如果把所有关键字存放在同一块盘中，那么盘中所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相应的，IO读写次数就降低了。

   ​		树的查询效率更加稳定。B+树所有数据都存在于叶子节点，所有关键字查询的路径长度相同，每次数据的查询效率相当。而B树可能在非叶子节点就停止查找了，所以查询效率不够稳定。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。

6. 哈希索引

   哈希索引就是采用一定的哈希算法，只需要一次哈希算法即可查询到相应的位置，速度非常快。

   哈希索引也有一定的局限性：

   1. 哈希索引没办法利用索引完成排序。
   2. 不能进行多字段查询。
   3. 在有大量重复键值的情况下，哈希索引的效率也是极低的（出现哈希碰撞问题）。
   4. 不支持范围查询。

7. IO操作

   每个节点的读取或者访问，都对应一次硬盘的IO操作，每次查询数据时磁盘IO操作的次数，也叫做IO渐进复杂度，或者称为树的高度。

   我们可以将二叉树变为N叉树，这样就减少了树的高度，那么N是不是可以无限大呢？

   不管是内存中的数据还是磁盘中的数据，操作系统都是按页（一页的大小通常是 4kb，这个值可以通过`getconfig(PAGE_SIZE)`命令查看）来读取的，一次只会读取一页的数据。

   如果要读取的数据量超过了一页的大小，就会触发多次 IO 操作。所以在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。