---
title: 并发事务
date: 2020-11-16 19:54:04
tags:
---

# 并发事务

​		并发是操作系统领域的一个概念，指的是一段时间内多任务流交替执行的现象。

​		高并发意味着大流量，就需要运用技术手段来抵抗流量的冲击，能让请求更准确的被系统所处理。高并发是互联网中，分布式系统构架设计中必须考虑的因素之一，它是指系统能够在同一时刻，同事处理多个请求的能力。一般有4项指标来衡量处理高并发能力。

1. 响应时间：系统对请求做出相应的时间

2. 吞吐量TPS：单位时间内处理的请求数量。包括一条消息入和一条消息出，加上一次用户数据库访问。

3. 每秒查询QPS：每秒响应请求数。

4. 并发用户数量：同时承载正常使用系统功能的用户数量。

   目前最基本的一个方法处理并发事务：锁

​	   锁是计算机为了保证数据在并发访问下的一致性，准确性，它是影响数据库并发访问性能的一个重要因素。锁是在MySQL在服务器层和储存引擎层的并发控制。

```python
# 我们举一个简单的例子，利用高并发对一个数值进行减法计算

    with transaction.atomic():
        task_obj = User.objects.select_for_update().get( pk=7 )
        # 判断数量大于0
        if task_obj.num > 0:
            task_obj.num = task_obj.num-1
            task_obj.save()
 
# 如果我们没有锁，那么结果肯定是负数
```



​		从锁定资源的角度来看，MySQL中的锁分为：表级锁，行级锁，页面锁。

​		表级锁：对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

​		行级锁：对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

​		页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

​		锁的粒度越大，准确度会变高，那么并发度就会降低，消耗时间也会增大。

在我们加锁的时候，需要注意几点：

1. 我们需要在加锁的位置注意，因为如果我们加锁的位置不对的话，所得到的结果就有偏差。

```python
 # 我们继续拿上面的例子
    with transaction.atomic():
        task_obj = User.objects.select_for_update().get( pk=7 )
        # 判断数量大于0
        if task_obj.num > 0:
            task_obj.num = task_obj.num-1
            task_obj.save()
 # 注意是先加锁，后判断，这种不管多少并发测试，结果都是0


# 这个例子就是先判断，后加锁
	with transaction.atomic():
        # 判断数量大于0
        if task_obj.num > 0:
        task_obj = User.objects.select_for_update().get( pk=7 )
            task_obj.num = task_obj.num-1
            task_obj.save()	
# 这种情况得到的结果大概率都是负数，而且并发量越高越明显。
```

所以加锁的位置要注意，对结果影响特别大。



