---
title: npm与yarn的那些事
date: 2020-11-01 19:09:01
tags:
---

# npm与yarn不得不说的那些事

每个团队都必须在开发过程中做出各种决定。其中通常会涉及到 `yarn`，`npm` 或其它用于构建和打包 javascript 代码的工具。一些开发人员渴望朝着某个方向前进，有时他们会花费大量时间来尝试，去做出实际上对他们的工作几乎没有什么影响的决策。

首先，要了解为什么要做出一个有趣的决定，我们需要看一下 javascript 中包管理的历史。

- **npm 出现之前**：前端依赖项是保存到存储库中并手动下载的
- **2010**：`npm` 发布并支持 `nodejs`
- **2012**：`npm` 的使用量急剧增加——主要是由于 `Browserifys` 浏览器的支持
- **2012**：`npm` 有了一个竞争对手 `bower`，它完全支持浏览器
- **2012-2016**：前端项目的依赖项数量成倍增加
- **2012-2016**：构建和安装前端应用变得越来越慢
- **2012-2016**：大量（重复的）依赖项存储在神奇的 `node_modules` 内的嵌套文件夹中
- **2012-2016**：`rm -rf node_modules` 成为前端开发人员最常用的命令。
- **2015**：`bower` 输给了 `npm`
- **2015**：`node_modules` 被修改为扁平化的文件结构！
- **2016**： `left-pad`[成为当时的新闻头条](https://link.zhihu.com/?target=https%3A//qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code)
- **2016**： `yarn` 发布
- 支持 `npm` 和 `bower` 仓库
- `yarn.lock` 能够锁定安装的版本并提供确定性的依赖关系。不再 `rm -rf node_modules`！
- `yarn install` 花费的时间是 `npm install` 的一半（不使用缓存的前提下）
- 缓存和脱机模式使构建过程几乎不花费时间
- **2016**：`npm` 发布 `shrinkwrap`
- 尝试处理依赖项锁定
- 不幸的是，一些错误和超出其管理能力的承诺导致该工具的声誉下降
- **2017**：`npm` 5 发布
- `package-lock.json` 是他们的新工具，`shrinkwrap` 被放在一边
- `package-lock.json` 开始与 `yarns` 锁定文件竞争
- **2018**：`npm ci` 发布
- 直接用 `package-lock.json` 构建代码
- 没有代价高昂的依赖项安全性分析和版本分析
- 大大减少了在构建服务器上的构建时间！
- **2018**：`npm` 6 发布 ‍♀️
- `npm` 检查要安装的依赖项中的安全漏洞
- `yarn` 和 `npm` 的构建时间不再有显差异
- **2019**：`tink` 开始进入 beta 模式
- 避免使用 `node_modules`，而是为项目中的每个依赖项创建一个带有哈希值的文件
- 尚未做好投入生产环境的准备

那么对于这两种管理方式，我们应该选择哪种的比较好呢？

​		如果你从事前端开发有些年头了，那你肯定对npm又爱又恨，爱就不说了，恨嘛，就是`npm`经常奇慢和卡顿，这还能忍，经常各种错误就没法忍了，尤其是他人创建的项目，自己在安装依赖的时候，经常会报一些各种`WARN`,，而且这些`WARN`并不会导致你的整个项目跑不起来，而是会让你的一些功能失效；

```
	比如本人在搭建个人博客平台时，用各种npm install hexo-asset-image都不起作用，每次都会报一个两个WARN结果就导致无论你怎么添加图片，最后hexo s时，图片就是显示不出来。但是你用yarn add https://github.com/CodeFalling/hexo-asset-image后，就能一次性OK。

​	我认为这就是npm和yarn最大的区别，npm 是按照package-json的内容从上至下一步一步安装依赖包，而yarn是根据你依赖包里的依赖关系去同步安装依赖包。还记得npm安装依赖包时，版本前都会带有一些前缀，比如"~"，"^"，安装依赖包时，大多数npm库都严重依赖于其他npm库，这会导致嵌套依赖关系，并增加无法匹配相应版本的几率。

​	虽然可以通过npm config set save-exact true命令关闭在版本号前面使用的默认行为，但这个只会影响顶级依赖关系。由于每个依赖的库都有自己的package.json文件，而在它们自己的依赖关系前面可能会有符号，所以无法通过package.json文件为嵌套依赖的内容提供保证。
```

​		`npm`还会给你搞一些其他的事情，比如当项目有些年头，一些依赖包已经有更新的时候，重新安装依赖包发生错误的概率甚至超过50%，这个实在没办法忍受。对于开发人员无疑是一种噩梦。

​		而`yarn`，则是完全碾压`npm`的存在~yarn不但速度甩`npm`十条街，而且很多`npm`死活安装不上的时候，`yarn`基本都是一次完美成功安装；在npm5出来后，很多人说有改善，但现在已经5.5了，经我们团队从github上拉取多个开源项目实际测试，`npm`安装依赖发生错误的概率仍然居高不下，很多项目尝试各种办法仍然无法成功安装依赖和运行，而同样的项目，用yarn安装，则基本一次完成，一次错误也未发生，都成功安装和运行

结语：

```
	在npm5.0之前，yarn的优势特别明显。但是在npm之后，通过以上一系列对比，我们可以看到 npm5 在速度和使用上确实有了很大提升，值得尝试，不过还没有超过yarn。
	我确信yarn是一个更安全的选择，但是pnpm可能是一些测试用例的更好的选择。例如，它可以在运行大量集成测试并希望尽可能快地安装依赖关系的中小型团队中发挥作用。
	如果你已经在个人项目上使用 yarn，并且没有遇到更多问题，目前完全可以继续使用。但如果有兼容 npm 的场景，或者身处在使用 npm，cnpm，tnpm 的团队，以及还没有切到 yarn 的项目，那现在就可以试一试 npm5 了。npm仍然提供了一个非常有用的解决方案，支持大量的测试用例。大多数开发人员使用原始npm客户端仍然可以做得很好。

```

